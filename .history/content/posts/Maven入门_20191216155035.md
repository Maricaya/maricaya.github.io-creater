---
title: "Maven入门"
date: 2019-12-16T18:55:11+08:00
draft: false
---

Maven是Java的包管理工具，类似于JavaScript的npm。Maven已经有十多年的历史，至今仍然被Java程序员广泛使用。要了解Maven，先了解最基本的概念。什么是包？

## 什么是包？
JVM是如何工作的？
JVM被设计的相当简单：1.执行一个类的字节码 2.假如这个过程中碰到了新的类，加载 -> 1.2...

那么，去哪里加载新的类？
命令行中可以执行的程序是从环境变量中找到的，类似的，新的类是通过类路径（classpath）挨个去找的。如果碰到jar包，就将jar包解压缩后寻找。jar包的本质就是zip压缩包，将jar改为zip后解压缩，可以看到一堆java类。
类的全限定类名唯一确定了一个类。
包，就是把许多类放在一起，压缩为jar包。
```bash
-classpath/-cp
```

## 什么是包管理？
使用的一些第三方类，需要告诉JVM从哪里找
包管理的本质就是，**告诉JVM从哪里找需要的第三方类。以及成功的解决其中的冲突问题。**

## 冲突问题
即你依赖的类还依赖了其他类。程序庞大的情况下，依赖可能非常多。在真实的项目中，可能依赖成百上千个jar包。如果使用命令行的方式一个一个传递，会导致效率十分低下。
这就是使用自动化工具的原因：帮我们完成重复、啰嗦的事情。

我们知道，类的唯一表示就是全限定类名。全限定类名是用来在jar包中，根据目录来定位文件的。如果依赖的两个包，分别依赖同一个同名文件，但是是不同的版本。那应该选择哪个版本呢？
答案很简单：**谁在前面，就用谁。**
在不同的版本中，代码是不同的，因此可能会出现bug。这就是**Classpath hell** 类路径地狱。
最早的解决方法是：每次上线前都看一下，确定没有同名类。但是Classpath很长，肉眼很难看出问题。

## 在没有Maven的时代
java程序员是手动写命令行进行程序的编译、运行。
依赖的所有jar包都需要手动下载，并且手动写上classpath。
```bash
# 编译 需要手动下载commons-lang3-3.9.jar 和lang3依赖的jar包
javac -cp commons-lang3-3.9.jar StringIsBlank.java
# 运行
java -cp commons-lang3-3.9.jar:. StringIsBlank.java 传递参数
```

## Apache Ant时代
手动下载jar包。并写xml配置，指定编译的源代码目录、依赖的jar包、输入目录等。

Ant时代已经节省了很多工作，但也有他的不足。
- 每个人都要造轮子。
  - 因为每个人的目录名称不同，并不通用。
- 依赖的第三方类库都需要手动下载。
- 没有解决classpath hell问题。

## Maven 划时代的包管理
首先要强调，Maven不仅仅是包管理工具。
- Maven为仓库提供了一套约定，可以复用其他人的代码。约定优于配置。
  - 不用手动去下载包，只要配置组织、名称、版本号。Maven会自动下载依赖的包。
- Maven有两个仓库：中央仓库、本地仓库(默认~/.m2) 下载的第三方包，放入m2进行缓存。
- Maven就像一个大书库，根据书的分类去找到下载的第三方包。

### Maven的包
- 按照约定为所有包编号，方便检索
  - groupId
  - artifactId
  - version